import{r as n,a as I,s as k,j as h,b as A,F as P}from"./index.22ea30a5.js";import{P as O,w as U,L as K,u as S,e as T}from"./motion.3259bc3b.js";function v(){const r=n.exports.useRef(!1);return I(()=>(r.current=!0,()=>{r.current=!1}),[]),r}function j(){const r=v(),[o,e]=n.exports.useState(0),t=n.exports.useCallback(()=>{r.current&&e(o+1)},[o]);return[n.exports.useCallback(()=>k.postRender(t),[t]),o]}class B extends n.exports.Component{getSnapshotBeforeUpdate(o){const e=this.props.childRef.current;if(e&&o.isPresent&&!this.props.isPresent){const t=this.props.sizeRef.current;t.height=e.offsetHeight||0,t.width=e.offsetWidth||0,t.top=e.offsetTop,t.left=e.offsetLeft}return null}componentDidUpdate(){}render(){return this.props.children}}function G({children:r,isPresent:o}){const e=n.exports.useId(),t=n.exports.useRef(null),m=n.exports.useRef({width:0,height:0,top:0,left:0});return n.exports.useInsertionEffect(()=>{const{width:f,height:u,top:c,left:x}=m.current;if(o||!t.current||!f||!u)return;t.current.dataset.motionPopId=e;const d=document.createElement("style");return document.head.appendChild(d),d.sheet&&d.sheet.insertRule(`
          [data-motion-pop-id="${e}"] {
            position: absolute !important;
            width: ${f}px !important;
            height: ${u}px !important;
            top: ${c}px !important;
            left: ${x}px !important;
          }
        `),()=>{document.head.removeChild(d)}},[o]),h(B,{isPresent:o,childRef:t,sizeRef:m,children:n.exports.cloneElement(r,{ref:t})})}const E=({children:r,initial:o,isPresent:e,onExitComplete:t,custom:m,presenceAffectsLayout:f,mode:u})=>{const c=A(D),x=n.exports.useId(),d=n.exports.useMemo(()=>({id:x,initial:o,isPresent:e,custom:m,onExitComplete:a=>{c.set(a,!0);for(const i of c.values())if(!i)return;t&&t()},register:a=>(c.set(a,!1),()=>c.delete(a))}),f?void 0:[e]);return n.exports.useMemo(()=>{c.forEach((a,i)=>c.set(i,!1))},[e]),n.exports.useEffect(()=>{!e&&!c.size&&t&&t()},[e]),u==="popLayout"&&(r=h(G,{isPresent:e,children:r})),h(O.Provider,{value:d,children:r})};function D(){return new Map}const R=r=>r.key||"";function H(r,o){r.forEach(e=>{const t=R(e);o.set(t,e)})}function V(r){const o=[];return n.exports.Children.forEach(r,e=>{n.exports.isValidElement(e)&&o.push(e)}),o}const _=({children:r,custom:o,initial:e=!0,onExitComplete:t,exitBeforeEnter:m,presenceAffectsLayout:f=!0,mode:u="sync"})=>{m&&(u="wait",U(!1,"Replace exitBeforeEnter with mode='wait'"));let[c]=j();const x=n.exports.useContext(K).forceRender;x&&(c=x);const d=v(),a=V(r);let i=a;const p=new Set,C=n.exports.useRef(i),w=n.exports.useRef(new Map).current,g=n.exports.useRef(!0);if(I(()=>{g.current=!1,H(a,w),C.current=i}),S(()=>{g.current=!0,w.clear(),p.clear()}),g.current)return h(P,{children:i.map(s=>h(E,{isPresent:!0,initial:e?void 0:!1,presenceAffectsLayout:f,mode:u,children:s},R(s)))});i=[...i];const y=C.current.map(R),M=a.map(R),z=y.length;for(let s=0;s<z;s++){const l=y[s];M.indexOf(l)===-1&&p.add(l)}return u==="wait"&&p.size&&(i=[]),p.forEach(s=>{if(M.indexOf(s)!==-1)return;const l=w.get(s);if(!l)return;const L=y.indexOf(s),b=()=>{w.delete(s),p.delete(s);const F=C.current.findIndex($=>$.key===s);if(C.current.splice(F,1),!p.size){if(C.current=a,d.current===!1)return;c(),t&&t()}};i.splice(L,0,h(E,{isPresent:!1,onExitComplete:b,custom:o,presenceAffectsLayout:f,mode:u,children:l},R(l)))}),i=i.map(s=>{const l=s.key;return p.has(l)?s:h(E,{isPresent:!0,presenceAffectsLayout:f,mode:u,children:s},R(s))}),T!=="production"&&u==="wait"&&i.length>1&&console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`),h(P,{children:p.size?i:i.map(s=>n.exports.cloneElement(s))})};export{_ as A};
